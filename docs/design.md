## Общие сведения об игре

Игра с видом сверху на клетчатом поле любого размера (на экране видна только его часть).
Цель игры — пройти уровень от входа до выхода.
Пользователь управляет персонажем, перемещаясь по карте и взаимодействую с различными игровыми объектами (например, стена, монетка, враг, вещь и т.д).

Объект типа вещь игрок может подобрать себе в инвентарь.
Вещь из инвентаря игрок может "надеть" на себя, при этом изменяются какие-то способности/характеристики (например, игрок ускоряется или получает возможность проходить сквозь стены).
При снятии вещи, она возвращается в инвентарь.

Есть вещи с одноразовым эффектом, например монетки или сердечки, увеличивающие количество здоровья.

При запуске игры инициализируется уровень: объекты и их положение либо случайно генерируются, либо подгружаются из файла.

После смерти персонажа игра завершается, и надо начинать сначала.

## Architectural drivers

- Технические ограничения: 
  - необходимо кроссплатформенное решение
  - важна скорость программы, так как это real-time игра
- Ограничения по срокам:
  - добавлять новые возможности в игру каждые пару недель
  - закончить проект до середины декабря
- Функциональные требования:
  - консольная графика
  - минимум 60fps
  - генерация карт
- Атрибуты качества:
  - расширямая архитектура
  - unit-тесты
  - понятный код

## Описание типичного пользователя

- Знаком с жанром roguelike 
- Опытный игрок, которому важна сложность прохождения, а не сюжет или графика
- Привык проходить игры на одной только клавиатуре
- Готов разбираться с большим набором правил и игровых механик

## Диаграмма компонентов

![component-diagram](.\data\roguelike-component-diagram.png)

## Диаграмма классов

![class-diagram](.\data\roguelike-class-diagram.png)

### Engine

Входная точка в программу, занимающаяся конфигурированием основных сущностей. Содержит основный цикл игры, хранит текущий `State`.

Состоит из:

- Компоненты `UI` 
- Компоненты `Controller`
- Хранит текущий `State`
- Набор некоторых вспомогательных классов, например, `AssetManager`

Отвечает за коммуникацию между `UI` и `Controller`, а также `Controller` и `State`.

### AssetManager

Вспомогательный класс, позволяющий загружать с диска различные файлы с данными, например, карты, характеристики и т. д.

### UI

Абстрактный класс, содержащий в себе всё взаимодействие с пользователем.

- Состоит из `Renderer`а
- Умеет получать примитивные `Event`ы, связанные с действиями пользователя:
  - Выбран элемент из списка
  - Нажата клавиша
  - Введено слово
  - etc.

Движок использует этот класс для отрисовки `View`, а тот в свою очередь, делегирует это `Renderer`у. Также движок использует этот класс
для получения UI событий, после чего передаёт эти события `Controller`у.


### Renderer

Интерфейс, предназначенный для отрисовки `View`. Реализация будет рендерить `View` на консоль.
Потенциально, можно реализовать и высокоуровневую графику.

### View

Абстрактный класс, представляющий базовую сущность рисования. Реализует паттерн "компоновщик". Потенциальные наследники:
 - `TextView`
 - `ProgressBar`
 - `RectangleBox`
 - `AsciiGrid`
 - `Button`
 - `CompositeView`

### Controller

Абстрактный класс, связывающий между собой внутренние модели игры и их представление:
 - Функция `bind(state: State): View` используется для получения `View` для текущего состояния. Для этого может использоваться
вспомогательный класс `ViewBuilder`. Движок вызывает эту функцию, когда хочет вывести пользователю какой-то `State`.
 - Функция `processEvent(event: Event): Message` получает UI событие и преобразует его в сообщение для текущего `State`. Например, "нажата клавиша <стрелочка вправо>" преобразуется в "сместить игрока вправо".

Функция `bind` может запоминать необходимые элементы `View`, чтобы потом корректно обработать `UI` событие.

### State

Состояние игры, содержащие все необходимые для корректной работы данные внутри себя.
Клиент (`Engine`) передаёт некоторое сообщение (`Message`), состояние обрабатывает это сообщение, изменяя свои внутренние данные, и возвращает следующие состояние, возможно, себя же. 
Для этого вызывается функция `process(Message): State`. Сообщения параметризуются конкретным типом состояния, то есть
у каждого состояния свой набор принимаемых сообщений.

Примеры:
- `LoadingScreenState`
- `MenuScreenState`
- `GameState`

Наибольший интерес представляет `GameState`.


### GameState

Содержит в себе текущие игровые данные и классы, реализующие основные игровые механики:

- Симулятор `Simulator`
- Игровый мир `World`
- Список стратегий для юнитов с икуственным интеллектом

По сути, реализует основную игровую логику одной итерации цикла.

Сообщением для `GameState` может быть, например, "игрок открыл инвентарь", "игрок передвинулся куда-то" или "игрок открыл меню".

### World

Содержит текущее состояние игрового мира:

- Карта в каком-то виде
- Список игровых объектов
- Список продолжительных эффектов
- Текущее время

### Strategy

Реализует поведение какого-либа юнита. Пользовательские действия тоже могут быть описаны этим интерфейсом. `GameState` для каждого юнита вычисляет
нужную стратегию, а затем у этой стратегии вызывает метод `getAction(unit, worldView)`, возврщающий действие юнита.
`WorldView` -- по сути некоторый иммутабельный кусок мира, который доступен юниту. Это позволяет реализовать, например, туман войны и прочие механики.

### Simulator

Реализация этого класса отвечает за обновление мира на основе действий юнитов. Именно здесь происходят все вычисления игровых механик.


## Диаграмма последовательностей

![image](https://user-images.githubusercontent.com/54814796/199162190-92c9605a-2030-4259-9300-1a34d2517df9.png)

Когда пользователь запускает игру, Engine инициализирует начальный GameState.

Далее, в бесконечном цикле, Engine получает текущий актуальный GameState, чтобы на основе него сконструировать View, которое Renderer отобразит на экране. 

В любой момент пользователь может совершить действие, например, нажать кнопку на клавиатуре.
Тогда Engine получит соответствующее событие от Controller, на основе которого обновит текущий GameState.

## Диаграмма конечных автоматов

![image](https://user-images.githubusercontent.com/54814796/199162111-03b7e2ed-9196-4a5e-8b40-df8b391c4e3f.png)

- Игрок начинает в состоянии Idle.
- При нажатии на клавиши перемещения происходит переход в состояние Moving, в котором игрок двигается по карте. Перед выходом из Moving игрок останавливается.
- При нажатии клавиши атаки, если текущее состояние — Idle или Move, игрок изменяет состояние на Attack, в котором атакует, после чего возвращается в то состояние, в котором был. 
- При получении урона игрок меняет состояние на Hurt, уменьшает количество своего здоровья, после чего возвращается в то состояние Idle. Если здоровье стало равным нулю, то игрок переходит в состояние Die.

